#!/bin/sh
#
# TODO: fix helper paths

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3
BRANCH=$(git branch --show-current)

echo "#" >>"$COMMIT_MSG_FILE"

case "$COMMIT_SOURCE,$SHA1" in
 ,)
	# This is a new commit. (Only get fancy when not doing rebases, etc.)

	# Dump diff into a file:
	PATCH=$(mktemp -t prepare-commit-msg-patch-XXXXXX)
	git diff --staged > "$PATCH"

	# Include diff in comments for easier review.
	awk '{print "# " $0}' <"$PATCH" >>"$COMMIT_MSG_FILE"

	# Get CC list.
	echo "Getting CC list ..." >&2
	~/bin/merge-cc "$PATCH" "$COMMIT_MSG_FILE"

	# Generate best-guess on prefixes...
	echo "Getting Subject prefixes ..." >&2
	PREFIX_FILE=$(mktemp -t prepare-commit-msg-prefix-XXXXXX)
	~/bin/get-prefix unknown $(diffstat -p1 -l < "$PATCH") >"$PREFIX_FILE"
	cat "$COMMIT_MSG_FILE" >>"$PREFIX_FILE"
	mv "$PREFIX_FILE" "$COMMIT_MSG_FILE"

	# Clean up
	rm -rf "$PATCH"
	;;
 merge,)
	# From https://superuser.com/questions/923676/figure-out-merged-commit-in-prepare-commit-msg-hook
	#
	# Retrieve merged branch name from an env var GITHEAD_<sha>=<branchName>
	# We cannot use a sym ref of MERGE_HEAD, as it doesn't yet exist
	gitHead=$(env | grep GITHEAD) # e.g. GITHEAD_<sha>=release/1.43
	# cut out everything up to the last "=" symbol
	MERGING="${gitHead##*=}"

	# Include the short log for reivew (like with a pull-request)
	git shortlog "$BRANCH".."$MERGING" | awk '{print "# " $0}' | sed -e 's/^# $/#/;' >>"$COMMIT_MSG_FILE"
	;;
 *)
	# Nothing to do
	;;
esac

# Quick sanity check about which branch we're working on.
echo "# BRANCH=$BRANCH" >>"$COMMIT_MSG_FILE"
# This doesn't need repeating: we're already editing the file.
#echo "# COMMIT_MSG_FILE=$COMMIT_MSG_FILE" >>"$COMMIT_MSG_FILE"
# Show source, for easier hook debugging.
echo "# COMMIT_SOURCE=$COMMIT_SOURCE" >>"$COMMIT_MSG_FILE"
# Include sha if available.
if [ -n "$SHA1" ]; then
	echo "# SHA1=$SHA1" >>"$COMMIT_MSG_FILE"
fi
